<html>
<head>
  <meta charset="UTF-8">
  <title>Lesson 1</title>
  <style>
    body {margin: 0px}
    canvas {width: "100%"; height: "100%"}
  </style>
  </head>
<body>
  <script src="js/three.min.js"></script>
  <script src="js/dat.gui.min.js"></script>
  <script>
    var raycaster, scene, camera, renderer, plane;
    var geometry, INTERSECTED, SELECTED;
    var points = [];

    var mouse = new THREE.Vector2();
    var offset = new THREE.Vector3();

    var userInterface = new function() {
      this.size = '100';
      this.kolor_tla = "#a6caf0";
      this.rzutowanie = false;
      this.Wyczyść = function() {resetScene()};
    }
    var gui = new dat.GUI();

    gui.add(userInterface, 'Wyczyść');

    init();
    render();

    function addPoint(Px, Py) {
      var pMaterial = new THREE.SpriteMaterial({color: "green"});
      var point = new THREE.Sprite(pMaterial);
      point.scale.x = point.scale.y = 10;
      point.position.x = Px;
      point.position.y = Py;
      scene.add(point);
      points.push(point);

      geometry.vertices.push(point.position);
        if (geometry.vertices.length >= 4) {
          var lines = new THREE.Line(geometry, new THREE.LineBasicMaterial({color: "black"}));
          lines.name = 'linie'
          scene.add(lines);

          var curve = new THREE.CubicBezierCurve(geometry.vertices[0], geometry.vertices[1], geometry.vertices[2], geometry.vertices[3]);
          var path = new THREE.Path( curve.getPoints( 30 ) );
          var Cgeometry = path.createPointsGeometry( 30 );
          var Cmaterial = new THREE.LineBasicMaterial( { color : 0xff0000 } );
          var cubicBezier = new THREE.Line(Cgeometry, Cmaterial);
          cubicBezier.name = 'bezier';
          scene.add(cubicBezier);
        }
    }

    function render() {
      camera.lookAt(scene.position);
      renderer.render(scene, camera);
    }

    function init(){
      container = document.createElement("div");
      document.body.appendChild(container);
      scene = new THREE.Scene();
      camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 1, 1000 );
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setClearColor("#a6caf0");
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      container.appendChild(renderer.domElement);

      raycaster = new THREE.Raycaster();

      plane = new THREE.Mesh(new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
          new THREE.MeshBasicMaterial( { visible: false } )
        );
      scene.add(plane);

      geometry = new THREE.Geometry();

      window.addEventListener("resize",onResize,false);
      renderer.domElement.addEventListener("mousemove",onMove,false);
      renderer.domElement.addEventListener("click",onClick,false);
      renderer.domElement.addEventListener("mousedown",onMouseDown,false);
      renderer.domElement.addEventListener("mouseup",onMouseUp,false);
    }

    function resetScene(){
      geometry.vertices = [];
      geometry.verticesNeedUpdate = true;
      scene.children = [];
      renderer.clear();
    }

    function onResize(){
      camera.left = window.innerWidth/-2;
      camera.right = window.innerWidth/2;
      camera.top = window.innerHeight/2;
      camera.down = window.innerWidth/-2;


      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMove(event){
      event.preventDefault();
      mouse.x = (event.clientX/window.innerWidth)*2-1;
      mouse.y = -(event.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse, camera);
      if (SELECTED) {
        requestAnimationFrame(render);
        var intersects = raycaster.intersectObject(plane);
        if (intersects.length > 0) {
        SELECTED.position.copy(intersects[0].point.sub(offset));
          geometry.verticesNeedUpdate = true;

          scene.remove(scene.getObjectByName('bezier'));
          var curve = new THREE.CubicBezierCurve(geometry.vertices[0], geometry.vertices[1], geometry.vertices[2], geometry.vertices[3]);
          var path = new THREE.Path( curve.getPoints( 30 ) );
          var Cgeometry = path.createPointsGeometry( 30 );
          var Cmaterial = new THREE.LineBasicMaterial( { color : 0xff0000 } );
          var cubicBezier = new THREE.Line(Cgeometry, Cmaterial);
          cubicBezier.name = 'bezier';
          scene.add(cubicBezier);

        }
        return;
      }

      var intersects = raycaster.intersectObjects(points);
      if(intersects.length > 0){
          //pierwszy element w tablicy intersects jest pierwszym trafionym(najwyzszym)
          if (INTERSECTED != intersects[0].object) {
            INTERSECTED = intersects[0].object;
            temp = INTERSECTED.material.color.getHex();
            INTERSECTED.material.color.set("red");
            plane.position.copy( INTERSECTED.position );
          }
        document.body.style.cursor = 'pointer';
      } else {
        if (INTERSECTED) INTERSECTED.material.color.setHex(temp);
        INTERSECTED = null;
        document.body.style.cursor = 'auto';
        }
      render();
    }

    function onClick(event){
      mouse.x = event.clientX - window.innerWidth/2;
      mouse.y = -(event.clientY - window.innerHeight/2);
      if(geometry.vertices.length < 4){
        addPoint(mouse.x, mouse.y);
      }
      render();
    }

    function onMouseDown(event){
      event.preventDefault();
      raycaster.setFromCamera(mouse, camera);
      mouse.x = (event.clientX/window.innerWidth)*2-1;
      mouse.y = -(event.clientY/window.innerHeight)*2+1;
      var intersects = raycaster.intersectObjects(points);
      if (intersects.length > 0) {
        SELECTED = intersects[0].object;
        var intersect = raycaster.intersectObject(plane);
        if (intersect.length > 0) {
          offset.copy(intersect[0].point).sub(plane.position);
        }
        document.body.style.cursor = 'move';
      }
      render();
    }

    function onMouseUp(event){
      event.preventDefault();
      if (INTERSECTED) {
        plane.position.copy(INTERSECTED.position);
        SELECTED = null;
      }
      document.body.style.cursor = 'auto';
    }
  </script>
</body>
</html>
